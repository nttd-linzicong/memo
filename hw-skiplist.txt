Programming Assignment 1 - Skip List

Prerequisites

UNIX/UNIX-like operating system
C++ development environment
Goals

More efficient List data structure: Skip List
More familiar with C++ programming: Class, Pointers, References, Pair, Complex Data Structure
Memory Management: allocate and free
Background

Skip List, invented by Bill Pugh in 1990, is a generalization of sorted linked lists.
Linked list which you have already learned is a linear collection of data elements, each element points to the next, allowing efficient insertion or removal of elements from any position in the sequence during iteration. The drawback of linked list is it's hard to search in less than O(n) time. Skip list can fix this drawback.
The expected search time of skip list is O(log n). Skip list is already sorted sequentially for searching. To find an item, we scan along the shortest list until we would "pass" the desired item. At that point, we drop down to a slightly more complete list at one level lower. In a perfect skip list, there are altogether O(log n) levels, because you cut the the number of items by half at each level. You will visit at most 2 nodes per level: if you visit more, then you could have done it on one level higher up. Therefore, search time is O(log n).
The implementation of skip list applies Randomization when generating the level of newly inserted node. Randomization allows for some imbalance, but the expected behavior remains the same as with perfect skip list.
source & recommend reference for you:
CMU
Wiki
Problem Description

For most of you, this might be your first try of implementing a complex data structure. it will not be easy but it will be a good start.
You are required to complete a Skip List with several functions in C++. Same as your hw0-Linked list, I/O is given, all you need to do is to finish the data structure. Implementation details are given in the skiplist.cpp. Here, we will show you some points worth paying attention to.
Skip List:
Take this big picture for example. big picture
The highest _level should not exceed _height_limit. The base level is labeled as Level 1. In the template, node **_forward is an array of pointers with length _level. Each entry in the _forward array is a pointer pointing to the next node in the corresponding level. We have a dummy node as _head which is allocated with memory and has _data: (Key(), Val()). The last node at each level points to NULL. In each node, key and val are encapsulated in std::pair. You may also want to use std::make_pair.
Initial condition:
When you construct skiplist and the dummy node, it should look like this:

The dummy node should be allocated with memory. But the tail are simply NULL, don't allocated memory for it. The initial level(the actual level) is 1, but _head->_forward has length _height_limit, you will understand why if you understand how skiplist works.
Remove:
There is one condition you should pay attention to:
If the only node with the highest level is removed, _level should decrease correspondingly.
For example, remove Node with key = 3 from big picture:

Free allocated memory:
In remove(), ~skiplist(), ~_node(), you will need to free some allocated memory. You might need to free memory allocated to _node itself or _forward. If you didn't allocate memory for them but later you use or free its members or functions, you will be awarded with Segment Fault/Runtime Error.
To test whether you have memory leak, you can use valgrind.
display()
This function shows what the Skip List looks like with an empty new line at the end of output. For example:
********* Skiplist ********
Level 6:                 3: c

Level 5:                 3: c

Level 4:                 3: c

Level 3:   1: a          3: c

Level 2:   1: a          3: c

Level 1:   1: a   2: b   3: c

Copy
We use std::setw() to make nodes aligned. To show more nodes to help you debug, the parameter for std::setw() is not very large. You can use this function to test some simple cases as shown above, but if you want to test something like 10.9876: 12345, the display will not be aligned. Such cases do exist in OJ testcases, now that we have provided I/O for you, you just need to concentrate on implementing this Data Structure and use display() to do some simple debugging.
Language Library Requirements

The libraries needed to implement this assignment have been included in the template, but if you need other libraries:
C++ libraries for string manipulation and input/output streams are allowed. A conservative list would be
<iostream>
<ostream>
<string>
<cstdlib>
<cstdio>

Copy
C++ libraries for containers and algorithms, including
<array>
<list>
<map>
<queue>
<set>
<stack>
<vector>
<algorithm>
<tuple>

Copy
are NOT allowed.
<vector> is used in I/O to improve the Robustness of Input, you are not allowed to use it in your code.
Input Specifications

The input will contain two parts. The first is a binary number 0/1 to indicate the type of data, where 0 means <int, string> and 1 means <float, int>. Following is the operations you shall do. The operations has the form op key and each line is one operation (notice that the insert operation needs an additional value). We have 4 different operations:
search(@):
@ key
Copy
insert(+):
+ key val
Copy
remove(-):
- key
Copy
display($): call the display() to show the skiplist
$
Copy
An input sample is given below:
Sample1:

1
+ 1.1 1
+ 2.2 2
$
+ 1.1 4
- 2.2
@ 2.2
$
Copy
Output Specifications

When there is a search operation, you shall print out the return value of that. When there is a $ operation, display() will be called. A sample output for the above sample input is shown below:
Sample1:

insert: 1.1: 1
insert: 2.2: 2
display:
********* Skiplist ********
Level 3: 1.1: 1

Level 2: 1.1: 1

Level 1: 1.1: 1 2.2: 2

insert: 1.1: 4
remove: 2.2
search: 2.2 false
display:
********* Skiplist ********
Level 3: 1.1: 4

Level 2: 1.1: 4

Level 1: 1.1: 4

Copy
NOTE:
Space at the end of each line and newline at the end of output will be ignored in OJ testing. You really don't need to worry about I/O as we have provided this for you. Just do some local testing to see whether you have implemented all the functions.
Testing Specifications

You will meet 3 different types of data: int, float and string. The int value you shall handle has the range [INT_MIN, INT_MAX] (int value has 32 bits, try to calculate INT_MIN and INT_MAX by yourselves); The float value has the range [-100.00000, 100.00000]; The string can contain any character you can display except spaces and tabs. The input has at most 50001 operations.
Hint

Compile with g++ in Ubuntu, then use < and > do IO redirection.
Warning

You must not use forbiddened library, or your score will be set to 0.
You must do the homework by yourself and follow the regulations regarding Plagiarism.
 Open Scratchpad (Alt+E)
 Submit
HW1 - Skip List
 Attended
 View Homework
 Scoreboard
 All Submissions
 Help
StatusLive...RuleOIProblem1Start at2018-09-30 09:00 End at2018-10-30 23:59 Duration735.0 hour(s)Host  robertking Partic. 39 (Attended)
Status
Judging Queue
Service Status
AboutContact UsPrivacyTerms of ServiceCopyright Complaint Language
© 2005 - 2017 Vijos.orgbuild20171123-7-gd5e7071-dirty沪ICP备14040537号
